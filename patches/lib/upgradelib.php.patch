diff --git a/lib/upgradelib.php b/lib/upgradelib.php
index 185671a..493349d 100644
--- a/lib/upgradelib.php
+++ b/lib/upgradelib.php
@@ -1522,7 +1522,7 @@ function install_core($version, $verbose) {
  * @return void, may throw exception
  */
 function upgrade_core($version, $verbose) {
-    global $CFG, $SITE, $DB, $COURSE;
+    global $CFG;
 
     raise_memory_limit(MEMORY_EXTRA);
 
@@ -1553,10 +1553,6 @@ function upgrade_core($version, $verbose) {
             upgrade_main_savepoint($result, $version, false);
         }
 
-        // In case structure of 'course' table has been changed and we forgot to update $SITE, re-read it from db.
-        $SITE = $DB->get_record('course', array('id' => $SITE->id));
-        $COURSE = clone($SITE);
-
         // perform all other component upgrade routines
         update_capabilities('moodle');
         log_update_descriptions('moodle');
@@ -2063,73 +2059,3 @@ function upgrade_rename_old_backup_files_using_shortname() {
         @rename($dir . '/' . $file, $dir . '/' . $newname);
     }
 }
-
-/**
- * Detect duplicate grade item sortorders and resort the
- * items to remove them.
- */
-function upgrade_grade_item_fix_sortorder() {
-    global $DB;
-
-    // The simple way to fix these sortorder duplicates would be simply to resort each
-    // affected course. But in order to reduce the impact of this upgrade step we're trying
-    // to do it more efficiently by doing a series of update statements rather than updating
-    // every single grade item in affected courses.
-
-    $transaction = $DB->start_delegated_transaction();
-
-    $sql = "SELECT DISTINCT g1.id, g1.courseid, g1.sortorder
-              FROM {grade_items} g1
-              JOIN {grade_items} g2 ON g1.courseid = g2.courseid
-             WHERE g1.sortorder = g2.sortorder AND g1.id != g2.id
-             ORDER BY g1.courseid ASC, g1.sortorder DESC, g1.id DESC";
-
-    // Get all duplicates in course order, highest sort order, and higest id first so that we can make space at the
-    // bottom higher end of the sort orders and work down by id.
-    $rs = $DB->get_recordset_sql($sql);
-
-    foreach($rs as $duplicate) {
-        $DB->execute("UPDATE {grade_items}
-                         SET sortorder = sortorder + 1
-                       WHERE courseid = :courseid AND
-                       (sortorder > :sortorder OR (sortorder = :sortorder2 AND id > :id))",
-            array('courseid' => $duplicate->courseid,
-                'sortorder' => $duplicate->sortorder,
-                'sortorder2' => $duplicate->sortorder,
-                'id' => $duplicate->id));
-    }
-    $rs->close();
-
-    $transaction->allow_commit();
-}
-
-/**
- * Detect file areas with missing root directory records and add them.
- */
-function upgrade_fix_missing_root_folders() {
-    global $DB, $USER;
-
-    $transaction = $DB->start_delegated_transaction();
-
-    $sql = "SELECT contextid, component, filearea, itemid
-              FROM {files}
-             WHERE (component <> 'user' OR filearea <> 'draft')
-          GROUP BY contextid, component, filearea, itemid
-            HAVING MAX(CASE WHEN filename = '.' AND filepath = '/' THEN 1 ELSE 0 END) = 0";
-
-    $rs = $DB->get_recordset_sql($sql);
-    $defaults = array('filepath' => '/',
-        'filename' => '.',
-        'userid' => 0, // Don't rely on any particular user for these system records.
-        'filesize' => 0,
-        'timecreated' => time(),
-        'timemodified' => time(),
-        'contenthash' => sha1(''));
-    foreach ($rs as $r) {
-        $pathhash = sha1("/$r->contextid/$r->component/$r->filearea/$r->itemid/.");
-        $DB->insert_record('files', (array)$r + $defaults +
-            array('pathnamehash' => $pathhash));
-    }
-    $rs->close();
-    $transaction->allow_commit();
-}
